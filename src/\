use std::{ops::Sub, f32::consts::PI, sync::Mutex};

use nalgebra::{Vector2, SimdValue};
use rand::{prelude::ThreadRng, Rng};
use rayon::iter::{IntoParallelIterator, ParallelIterator, IndexedParallelIterator, IntoParallelRefMutIterator, IntoParallelRefIterator};

// Alright so here is the explanation of the algorithm, perlin noise is created by first creating a grid array, each cell in the grid
// is assigned a vector pointing in a random direction. that vector creates a gradient, pointing to 1 and having 0 in the other direction with smoothly interpolated values between i.e a gradient.
// then we create another grid that we overlay on top of the original cell grid, we poll values at the location of every cell and we average it with nearby cells. thats how we get the classic noise.
//
// This is not exactly perlin noise, but rather a smart reimplementation of it. Since we know that we are working on a grid we dont need to generate all the data necessary.
// By creating N amount of "stamps" that we can "press" onto the returning grid we can skip the overhead of calculating the dot product a lot of times, we do it a single time and we just reuse the results.
// we will call this N variable "accuracy"
// as N approaches infinity we will approach the original implementation of perlin noise, but I wager accuracy of 8 or 16 should be enough to make a nice looking perlin-ish noise.
// We will create N stamps with each stamp having a precalculated vector pointing in a direction (2*PI/N) * i , meaning each vector will be exactly 2*PI/N away from eachother.

fn main() {
    print_noise(&gen_noise(21, 9, 255, 0.0, 1.0));
}

#[derive(Debug,Default,Clone)]
struct Stamp{
    data: Vec<Vec<f32>>
}


impl Stamp{
    fn new(vector: &Vector2<f32>,size: usize) -> Self{

        let mut v : Vec<Vec<f32>>= Vec::new();
        for x in 0..size{
            v.push(Vec::new());
            for _ in 0..size{
                v[x].push(0.0f32);
            }
        }

        let fsize = size as f32;
        for x in 0..size {
            let fx = x as f32;
            for y in 0..size {
                let fy = y as f32;
                v[x][y] = (smoothstep(Vector2::new( fx - (fsize/2.0)+ 0.5 ,fy - (fsize/2.0)+ 0.5).scale(1.0/( (fsize/2.0)*2.0f32.sqrt())  ).dot(&vector)) * 1000.0).round() / 1000.0;
            }
        }

        Stamp{
            data: v ,
        }
    }
}

fn smoothstep(x: f32) -> f32{
    (4.0 * x).tanh()
}

fn gen_stamps(accuracy: u32,size: usize) -> Vec<Stamp>{
    let step : f32 = 2.0*PI / accuracy as f32;
    (0..accuracy).into_par_iter().map(|i| {
        Stamp::new(&Vector2::new((i as f32*step).cos(), (i as f32*step).sin()), size)
    }).collect()
}

fn gen_noise(accuracy: u32, stamp_size: usize, world_size: usize, lower_range: f32, upper_range: f32) -> Vec<Vec<bool>>{
    let mut rng = ThreadRng::default();
    let stamps = gen_stamps(accuracy, stamp_size);
    let real_world_size = (((world_size + 2 )as f32/stamp_size as f32).ceil() * stamp_size as f32) as usize;
    println!("{}",real_world_size);
    let mut stamp_vec : Vec<Vec<u32>> = Vec::new();
    for x in 0..real_world_size/stamp_size {
        stamp_vec.push(Vec::new());
        stamp_vec[x].resize(real_world_size/stamp_size, 0);
        for y in 0..real_world_size/stamp_size {
            stamp_vec[x][y] = rng.gen::<u32>() % accuracy;
        }
    }

    let mut v : Vec<Vec<bool>> = Vec::new();

    for x in 0..real_world_size{
        v.push(Vec::new());
        v[x].resize(real_world_size, false);
    }

    let pre_interpolation = v.par_iter_mut().enumerate().map(|xv|{
        let x = xv.0;
        xv.1.iter_mut().enumerate().map(|cell|{
            let y = cell.0;
            let data = stamps[stamp_vec[x/stamp_size][y/stamp_size] as usize].data[x % stamp_size][y % stamp_size];
            data
        }).collect::<Vec<f32>>()
    }).collect::<Vec<Vec<f32>>>();

    pre_interpolation.clone().par_iter().enumerate().map(|row|{
        let x = row.0;
        row.1.par_iter().enumerate().map(|cell|{
            let y = cell.0;
            let mut acc = pre_interpolation[x][y];
            let mut div = 1.0f32;
            let mut xy_neg_corner = 0;
            let mut xy_pos_corner = 0;
            /*if x as i32 - 1 >= 0 {
                acc += pre_interpolation[x - 1][y];
                div += 1.0;
                xy_neg_corner += 1;
            }
            if y as i32 - 1 >= 0 {
                acc += pre_interpolation[x][y - 1];
                div += 1.0;
                xy_neg_corner += 1;
            }
            if xy_neg_corner == 2 {
                acc += pre_interpolation[x - 1][y - 1];
                div += 1.0;
            }

            if x + 1 < real_world_size {
                acc += pre_interpolation[x + 1][y];
                div += 1.0;
                xy_pos_corner += 1;
            }
            if y + 1 < real_world_size {
                acc += pre_interpolation[x][y + 1];
                div += 1.0;
                xy_pos_corner += 1;
            }
            if xy_pos_corner == 2 {
                acc += pre_interpolation[x + 1][y + 1];
                div += 1.0;
            }*/

            let val = smoothstep(acc/div);
            val >= lower_range && val < upper_range
        }).collect()
    }).collect()
}

fn print_noise(vec: &Vec<Vec<bool>>){
    for x in 0..vec.len(){
        for y in 0..vec[x].len(){
            if vec[x][y] {
                print!("X");
            } else {
                print!(" ");
            }
        }
        print!("\n");
    }
}
